diff -up iptables-1.4.7/extensions/libip6t_set.c.ipXt_set iptables-1.4.7/extensions/libip6t_set.c
--- iptables-1.4.7/extensions/libip6t_set.c.ipXt_set	2015-03-03 22:22:02.624037158 +0100
+++ iptables-1.4.7/extensions/libip6t_set.c	2015-03-03 22:22:02.624037158 +0100
@@ -0,0 +1,159 @@
+/* Copyright (C) 2000-2002 Joakim Axelsson <gozem@linux.nu>
+ *                         Patrick Schaaf <bof@bof.de>
+ *                         Martin Josefsson <gandalf@wlug.westbo.se>
+ * Copyright (C) 2003-2004 Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.  
+ */
+
+/* Shared library add-on to iptables to add IP set matching. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <ctype.h>
+#include <errno.h>
+
+#include <xtables.h>
+#include <linux/netfilter_ipv6/ip6t_set.h>
+#include "libip6t_set.h"
+
+static void set_help(void)
+{
+	printf("set match options:\n"
+	       " [!] --match-set name flags\n"
+	       "		 'name' is the set name from to match,\n" 
+	       "		 'flags' are the comma separated list of\n"
+	       "		 'src' and 'dst' specifications.\n");
+}
+
+static const struct option set_opts[] = {
+	{ .name = "match-set", .has_arg = true, .val = '1'},
+	{ .name = "set",       .has_arg = true, .val = '2'},
+	{ .name = NULL }
+};
+
+static void set_init(struct xt_entry_match *match)
+{
+	struct xt_set_info_match *info = 
+		(struct xt_set_info_match *) match->data;
+	
+
+	memset(info, 0, sizeof(struct xt_set_info_match));
+
+}
+
+static int set_parse(int c, char **argv, int invert, unsigned int *flags,
+                     const void *entry, struct xt_entry_match **match)
+{
+	struct xt_set_info_match *myinfo = 
+		(struct xt_set_info_match *) (*match)->data;
+	struct xt_set_info *info = &myinfo->match_set;
+
+	switch (c) {
+	case '2':
+#if 0
+		fprintf(stderr,
+			"--set option deprecated, please use --match-set\n");
+#endif
+	case '1':		/* --match-set <set> <flag>[,<flag> */
+		if (info->flags)
+			xtables_error(PARAMETER_PROBLEM,
+				   "--match-set can be specified only once");
+
+		xtables_check_inverse(optarg, &invert, &optind, 0, argv);
+		if (invert)
+			info->flags |= IPSET_INV_MATCH;
+
+		if (!argv[optind]
+		    || argv[optind][0] == '-'
+		    || argv[optind][0] == '!')
+			xtables_error(PARAMETER_PROBLEM,
+				   "--match-set requires two args.");
+
+		if (strlen(optarg) > IP_SET_MAXNAMELEN - 1)
+			xtables_error(PARAMETER_PROBLEM,
+				   "setname `%s' too long, max %d characters.",
+				   optarg, IP_SET_MAXNAMELEN - 1);
+
+		get_set_byname(optarg, info);
+		parse_bindings(argv[optind], info);
+		DEBUGP("parse: set index %u\n", info->index);
+		optind++;
+		
+		*flags = 1;
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+static void set_check(unsigned int flags)
+{
+	if (!flags)
+		xtables_error(PARAMETER_PROBLEM,
+			   "You must specify `--match-set' with proper arguments");
+	DEBUGP("final check OK\n");
+}
+
+static void
+print_match(const char *prefix, const struct xt_set_info *info)
+{
+        int i;
+        char setname[IP_SET_MAXNAMELEN];
+
+        get_set_byid(setname, info->index);
+        printf("%s%s %s",
+               (info->flags & IPSET_INV_MATCH) ? "! " : "",
+               prefix,
+               setname); 
+        for (i = 1; i <= info->dim; i++) {              
+                printf("%s%s",
+                       i == 1 ? " " : ",",
+                       info->flags & (1 << i) ? "src" : "dst");
+        }
+	printf(" ");
+}
+
+/* Prints out the matchinfo. */
+static void set_print(const void *ip, const struct xt_entry_match *match,
+                      int numeric)
+{
+	const struct xt_set_info_match *info = (const void *)match->data;
+
+	print_match("match-set", &info->match_set);
+}
+
+static void set_save(const void *ip, const struct xt_entry_match *match)
+{
+	const struct xt_set_info_match *info = (const void *)match->data;
+
+	print_match("--match-set", &info->match_set);
+}
+
+static struct xtables_match set_mt6_reg = {
+	.name		= "set",
+	.revision       = 1,
+	.version	= XTABLES_VERSION,
+	.family		= NFPROTO_IPV6,
+	.size		= XT_ALIGN(sizeof(struct xt_set_info_match)),
+	.userspacesize	= XT_ALIGN(sizeof(struct xt_set_info_match)),
+	.help		= set_help,
+	.init		= set_init,
+	.parse		= set_parse,
+	.final_check	= set_check,
+	.print		= set_print,
+	.save		= set_save,
+	.extra_opts	= set_opts,
+};
+
+void _init(void)
+{
+	xtables_register_match(&set_mt6_reg);
+}
diff -up iptables-1.4.7/extensions/libip6t_SET.c.ipXt_set iptables-1.4.7/extensions/libip6t_SET.c
--- iptables-1.4.7/extensions/libip6t_SET.c.ipXt_set	2015-03-03 22:22:02.624037158 +0100
+++ iptables-1.4.7/extensions/libip6t_SET.c	2015-03-03 22:22:02.624037158 +0100
@@ -0,0 +1,163 @@
+/* Copyright (C) 2000-2002 Joakim Axelsson <gozem@linux.nu>
+ *                         Patrick Schaaf <bof@bof.de>
+ *                         Martin Josefsson <gandalf@wlug.westbo.se>
+ * Copyright (C) 2003-2004 Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.  
+ */
+
+/* Shared library add-on to iptables to add IP set mangling target. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <ctype.h>
+
+#include <xtables.h>
+#include <linux/netfilter_ipv4/ip_set.h>
+#include <linux/netfilter_ipv6/ip6t_set.h>
+#include "libip6t_set.h"
+
+static void SET_help(void)
+{
+	printf("SET target options:\n"
+	       " --add-set name flags\n"
+	       " --del-set name flags\n"
+	       "		add/del src/dst IP/port from/to named sets,\n"
+	       "		where flags are the comma separated list of\n"
+	       "		'src' and 'dst' specifications.\n");
+}
+
+static const struct option SET_opts[] = {
+	{ .name = "add-set", .has_arg = true, .val = '1'},
+	{ .name = "del-set", .has_arg = true, .val = '2'},
+	{ .name = NULL }
+};
+
+static void SET_init(struct xt_entry_target *target)
+{
+	struct xt_set_info_target *info =
+	    (struct xt_set_info_target *) target->data;
+
+	memset(info, 0, sizeof(struct xt_set_info_target));
+	info->add_set.index =
+	info->del_set.index = IP_SET_INVALID_ID;
+
+}
+
+static void
+parse_target(char **argv, int invert, unsigned int *flags,
+             struct xt_set_info *info, const char *what)
+{
+	if (info->flags)
+		xtables_error(PARAMETER_PROBLEM,
+			   "--%s can be specified only once", what);
+
+	if (xtables_check_inverse(optarg, &invert, NULL, 0, argv))
+		xtables_error(PARAMETER_PROBLEM,
+			   "Unexpected `!' after --%s", what);
+
+	if (!argv[optind]
+	    || argv[optind][0] == '-' || argv[optind][0] == '!')
+		xtables_error(PARAMETER_PROBLEM,
+			   "--%s requires two args.", what);
+
+	if (strlen(optarg) > IP_SET_MAXNAMELEN - 1)
+		xtables_error(PARAMETER_PROBLEM,
+			   "setname `%s' too long, max %d characters.",
+			   optarg, IP_SET_MAXNAMELEN - 1);
+
+	get_set_byname(optarg, info);
+	parse_bindings(argv[optind], info);
+	optind++;
+	
+	*flags = 1;
+}
+
+static int SET_parse(int c, char **argv, int invert, unsigned int *flags,
+                     const void *entry, struct xt_entry_target **target)
+{
+	struct xt_set_info_target *myinfo =
+	    (struct xt_set_info_target *) (*target)->data;
+
+	switch (c) {
+	case '1':		/* --add-set <set> <flags> */
+		parse_target(argv, invert, flags,
+			     &myinfo->add_set, "add-set");
+		break;
+	case '2':		/* --del-set <set>[:<flags>] <flags> */
+		parse_target(argv, invert, flags,
+			     &myinfo->del_set, "del-set");
+		break;
+
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+static void SET_check(unsigned int flags)
+{
+	if (!flags)
+		xtables_error(PARAMETER_PROBLEM,
+			   "You must specify either `--add-set' or `--del-set'");
+}
+
+static void
+print_target(const char *prefix, const struct xt_set_info *info)
+{
+	int i;
+	char setname[IP_SET_MAXNAMELEN];
+
+	if (info->index == IP_SET_INVALID_ID)
+		return;
+	get_set_byid(setname, info->index);
+	printf("%s %s", prefix, setname);
+	for (i = 1; i <= info->dim; i++) {
+		printf("%s%s",
+		       i == 1 ? " " : ",",
+		       info->flags & (1 << i) ? "src" : "dst");
+	}
+	printf(" ");
+}
+
+static void SET_print(const void *ip, const struct xt_entry_target *target,
+                      int numeric)
+{
+	const struct xt_set_info_target *info = (const void *)target->data;
+
+	print_target("add-set", &info->add_set);
+	print_target("del-set", &info->del_set);
+}
+
+static void SET_save(const void *ip, const struct xt_entry_target *target)
+{
+	const struct xt_set_info_target *info = (const void *)target->data;
+
+	print_target("--add-set", &info->add_set);
+	print_target("--del-set", &info->del_set);
+}
+
+static struct xtables_target set_tg_reg = {
+	.name		= "SET",
+	.revision	= 1,
+	.version	= XTABLES_VERSION,
+	.family		= NFPROTO_IPV6,
+	.size		= XT_ALIGN(sizeof(struct xt_set_info_target)),
+	.userspacesize	= XT_ALIGN(sizeof(struct xt_set_info_target)),
+	.help		= SET_help,
+	.init		= SET_init,
+	.parse		= SET_parse,
+	.final_check	= SET_check,
+	.print		= SET_print,
+	.save		= SET_save,
+	.extra_opts	= SET_opts,
+};
+
+void _init(void)
+{
+	xtables_register_target(&set_tg_reg);
+}
diff -up iptables-1.4.7/extensions/libip6t_set.h.ipXt_set iptables-1.4.7/extensions/libip6t_set.h
--- iptables-1.4.7/extensions/libip6t_set.h.ipXt_set	2015-03-03 22:22:02.624037158 +0100
+++ iptables-1.4.7/extensions/libip6t_set.h	2015-03-03 22:22:02.624037158 +0100
@@ -0,0 +1,124 @@
+#ifndef _LIBIP6T_SET_H
+#define _LIBIP6T_SET_H
+
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <errno.h>
+
+#ifdef DEBUG
+#define DEBUGP(x, args...) fprintf(stderr, x, ## args)
+#else
+#define DEBUGP(x, args...) 
+#endif
+
+static void
+parse_bindings(const char *opt_arg, struct xt_set_info *info)
+{
+	char *saved = strdup(opt_arg);
+	char *ptr, *tmp = saved;
+	
+        while (info->dim < IP_SET_MAX_BINDINGS && tmp != NULL) {
+		info->dim++;
+		ptr = strsep(&tmp, ",");
+		if (strncmp(ptr, "src", 3) == 0)
+			info->flags |= (1 << info->dim);
+		else if (strncmp(ptr, "dst", 3) != 0)
+			xtables_error(PARAMETER_PROBLEM,
+				   "You must specify (the comma separated list of) 'src' or 'dst'.");
+	}
+
+	if (tmp)
+		xtables_error(PARAMETER_PROBLEM,
+			   "Can't follow bindings deeper than %i.", 
+			   IP_SET_MAX_BINDINGS - 1);
+
+	free(saved);
+}
+
+static int get_version(unsigned *version)
+{
+	int res, sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
+	struct ip_set_req_version req_version;
+	socklen_t size = sizeof(req_version);
+	
+	if (sockfd < 0)
+		xtables_error(OTHER_PROBLEM,
+			   "Can't open socket to ipset.\n");
+
+	if (fcntl(sockfd, F_SETFD, FD_CLOEXEC) == -1) {
+		xtables_error(OTHER_PROBLEM,
+			      "Could not set close on exec: %s\n",
+			      strerror(errno));
+	}
+
+	req_version.op = IP_SET_OP_VERSION;
+	res = getsockopt(sockfd, SOL_IP, SO_IP_SET, &req_version, &size);
+	if (res != 0)
+		xtables_error(OTHER_PROBLEM,
+			   "Kernel module ip_set is not loaded in.\n");
+
+	*version = req_version.version;
+	
+	return sockfd;
+}
+
+static void get_set_byname(const char *setname, struct xt_set_info *info)
+{
+	struct ip_set_req_get_set req;
+	socklen_t size = sizeof(struct ip_set_req_get_set);
+	int res, sockfd;
+
+	sockfd = get_version(&req.version);
+	req.op = IP_SET_OP_GET_BYNAME;
+	strncpy(req.set.name, setname, IP_SET_MAXNAMELEN);
+	req.set.name[IP_SET_MAXNAMELEN - 1] = '\0';
+	res = getsockopt(sockfd, SOL_IP, SO_IP_SET, &req, &size);
+	close(sockfd);
+
+	if (res != 0)
+		xtables_error(OTHER_PROBLEM,
+			   "Problem when communicating with ipset, errno=%d.\n",
+			   errno);
+	if (size != sizeof(struct ip_set_req_get_set))
+		xtables_error(OTHER_PROBLEM,
+			   "Incorrect return size from kernel during ipset lookup, "
+			   "(want %zu, got %zu)\n",
+			   sizeof(struct ip_set_req_get_set), (size_t)size);
+	if (req.set.index == IP_SET_INVALID_ID)
+		xtables_error(PARAMETER_PROBLEM,
+			   "Set %s doesn't exist.\n", setname);
+
+	info->index = req.set.index;
+}
+
+static void get_set_byid(char * setname, ip_set_id_t idx)
+{
+	struct ip_set_req_get_set req;
+	socklen_t size = sizeof(struct ip_set_req_get_set);
+	int res, sockfd;
+
+	sockfd = get_version(&req.version);
+	req.op = IP_SET_OP_GET_BYINDEX;
+	req.set.index = idx;
+	res = getsockopt(sockfd, SOL_IP, SO_IP_SET, &req, &size);
+	close(sockfd);
+
+	if (res != 0)
+		xtables_error(OTHER_PROBLEM,
+			   "Problem when communicating with ipset, errno=%d.\n",
+			   errno);
+	if (size != sizeof(struct ip_set_req_get_set))
+		xtables_error(OTHER_PROBLEM,
+			   "Incorrect return size from kernel during ipset lookup, "
+			   "(want %zu, got %zu)\n",
+			   sizeof(struct ip_set_req_get_set), (size_t)size);
+	if (req.set.name[0] == '\0')
+		xtables_error(PARAMETER_PROBLEM,
+			   "Set id %i in kernel doesn't exist.\n", idx);
+
+	strncpy(setname, req.set.name, IP_SET_MAXNAMELEN);
+}
+
+#endif /*_LIBIP6T_SET_H*/
diff -up iptables-1.4.7/extensions/libip6t_set.man.ipXt_set iptables-1.4.7/extensions/libip6t_set.man
--- iptables-1.4.7/extensions/libip6t_set.man.ipXt_set	2015-03-03 22:22:02.624037158 +0100
+++ iptables-1.4.7/extensions/libip6t_set.man	2015-03-03 22:22:02.624037158 +0100
@@ -0,0 +1,23 @@
+This module matches IP sets which can be defined by ipset(8).
+.TP
+[\fB!\fP] \fB\-\-match\-set\fP \fIsetname\fP \fIflag\fP[\fB,\fP\fIflag\fP]...
+where flags are the comma separated list of
+.BR "src"
+and/or
+.BR "dst" 
+specifications and there can be no more than six of them. Hence the command
+.IP
+ iptables \-A FORWARD \-m set \-\-match\-set test src,dst
+.IP
+will match packets, for which (if the set type is ipportmap) the source
+address and destination port pair can be found in the specified set. If
+the set type of the specified set is single dimension (for example ipmap),
+then the command will match packets for which the source address can be
+found in the specified set. 
+.PP
+The option \fB\-\-match\-set\fR can be replaced by \fB\-\-set\fR if that does 
+not clash with an option of other extensions.
+.PP
+Use of -m set requires that ipset kernel support is provided. As standard
+kernels do not ship this currently, the ipset or Xtables-addons package needs
+to be installed.
diff -up iptables-1.4.7/extensions/libip6t_SET.man.ipXt_set iptables-1.4.7/extensions/libip6t_SET.man
--- iptables-1.4.7/extensions/libip6t_SET.man.ipXt_set	2015-03-03 22:22:02.625037155 +0100
+++ iptables-1.4.7/extensions/libip6t_SET.man	2015-03-03 22:22:02.625037155 +0100
@@ -0,0 +1,18 @@
+This modules adds and/or deletes entries from IP sets which can be defined 
+by ipset(8).
+.TP
+\fB\-\-add\-set\fP \fIsetname\fP \fIflag\fP[\fB,\fP\fIflag\fP...]
+add the address(es)/port(s) of the packet to the sets
+.TP
+\fB\-\-del\-set\fP \fIsetname\fP \fIflag\fP[\fB,\fP\fIflag\fP...]
+delete the address(es)/port(s) of the packet from the sets
+.IP
+where flags are
+.BR "src"
+and/or
+.BR "dst"
+specifications and there can be no more than six of them.
+.PP
+Use of -j SET requires that ipset kernel support is provided. As standard
+kernels do not ship this currently, the ipset or Xtables-addons package needs
+to be installed.
diff -up iptables-1.4.7/extensions/libipt_set.c.ipXt_set iptables-1.4.7/extensions/libipt_set.c
--- iptables-1.4.7/extensions/libipt_set.c.ipXt_set	2010-03-01 15:11:28.000000000 +0100
+++ iptables-1.4.7/extensions/libipt_set.c	2015-03-03 22:22:19.274974016 +0100
@@ -36,22 +36,76 @@ static const struct option set_opts[] =
 	{ .name = NULL }
 };
 
+static void set_init_v0(struct xt_entry_match *match)
+{
+	struct xt_set_info_match_v0 *info = 
+		(struct xt_set_info_match_v0 *) match->data;
+
+	memset(info, 0, sizeof(struct xt_set_info_match_v0));
+}
+
 static void set_init(struct xt_entry_match *match)
 {
-	struct ipt_set_info_match *info = 
-		(struct ipt_set_info_match *) match->data;
-	
+	struct xt_set_info_match *info = 
+		(struct xt_set_info_match *) match->data;
+
+	memset(info, 0, sizeof(struct xt_set_info_match));
+}
+
+static int set_parse_v0(int c, char **argv, int invert, unsigned int *flags,
+			const void *entry, struct xt_entry_match **match)
+{
+	struct xt_set_info_match_v0 *myinfo = 
+		(struct xt_set_info_match_v0 *) (*match)->data;
+	struct xt_set_info_v0 *info = &myinfo->match_set;
+
+	switch (c) {
+	case '2':
+#if 0
+		fprintf(stderr,
+			"--set option deprecated, please use --match-set\n");
+#endif
+	case '1':		/* --match-set <set> <flag>[,<flag> */
+		if (info->u.flags[0])
+			xtables_error(PARAMETER_PROBLEM,
+				   "--match-set can be specified only once");
 
-	memset(info, 0, sizeof(struct ipt_set_info_match));
+		xtables_check_inverse(optarg, &invert, &optind, 0, argv);
+		if (invert)
+			info->u.flags[0] |= IPSET_INV_MATCH;
 
+		if (!argv[optind]
+		    || argv[optind][0] == '-'
+		    || argv[optind][0] == '!')
+			xtables_error(PARAMETER_PROBLEM,
+				   "--match-set requires two args.");
+
+		if (strlen(optarg) > IP_SET_MAXNAMELEN - 1)
+			xtables_error(PARAMETER_PROBLEM,
+				   "setname `%s' too long, max %d characters.",
+				   optarg, IP_SET_MAXNAMELEN - 1);
+
+		get_set_byname(optarg, (struct xt_set_info *)info);
+		parse_bindings_v0(argv[optind], info);
+		DEBUGP("parse: set index %u\n", info->index);
+		optind++;
+		
+		*flags = 1;
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
 }
 
 static int set_parse(int c, char **argv, int invert, unsigned int *flags,
                      const void *entry, struct xt_entry_match **match)
 {
-	struct ipt_set_info_match *myinfo = 
-		(struct ipt_set_info_match *) (*match)->data;
-	struct ipt_set_info *info = &myinfo->match_set;
+	struct xt_set_info_match *myinfo = 
+		(struct xt_set_info_match *) (*match)->data;
+	struct xt_set_info *info = &myinfo->match_set;
 
 	switch (c) {
 	case '2':
@@ -60,13 +114,13 @@ static int set_parse(int c, char **argv,
 			"--set option deprecated, please use --match-set\n");
 #endif
 	case '1':		/* --match-set <set> <flag>[,<flag> */
-		if (info->flags[0])
+		if (info->flags)
 			xtables_error(PARAMETER_PROBLEM,
 				   "--match-set can be specified only once");
 
 		xtables_check_inverse(optarg, &invert, &optind, 0, argv);
 		if (invert)
-			info->flags[0] |= IPSET_MATCH_INV;
+			info->flags |= IPSET_INV_MATCH;
 
 		if (!argv[optind]
 		    || argv[optind][0] == '-'
@@ -103,58 +157,121 @@ static void set_check(unsigned int flags
 }
 
 static void
-print_match(const char *prefix, const struct ipt_set_info *info)
+print_match_v0(const char *prefix, const struct xt_set_info_v0 *info)
 {
-	int i;
-	char setname[IP_SET_MAXNAMELEN];
+        int i;
+        char setname[IP_SET_MAXNAMELEN];
 
-	get_set_byid(setname, info->index);
+        get_set_byid(setname, info->index);
 	printf("%s%s %s", 
-	       (info->flags[0] & IPSET_MATCH_INV) ? "! " : "",
+	       (info->u.flags[0] & IPSET_MATCH_INV) ? "! " : "",
 	       prefix,
 	       setname); 
 	for (i = 0; i < IP_SET_MAX_BINDINGS; i++) {
-		if (!info->flags[i])
-			break;		
+		if (!info->u.flags[i])
+			break;          
 		printf("%s%s",
 		       i == 0 ? " " : ",",
-		       info->flags[i] & IPSET_SRC ? "src" : "dst");
+		       info->u.flags[i] & IPSET_SRC ? "src" : "dst");
 	}
 	printf(" ");
 }
 
+static void
+print_match(const char *prefix, const struct xt_set_info *info)
+{
+        int i;
+        char setname[IP_SET_MAXNAMELEN];
+
+        get_set_byid(setname, info->index);
+        printf("%s%s %s",
+               (info->flags & IPSET_INV_MATCH) ? "! " : "",
+               prefix,
+               setname); 
+        for (i = 1; i <= info->dim; i++) {              
+                printf("%s%s",
+                       i == 1 ? " " : ",",
+                       info->flags & (1 << i) ? "src" : "dst");
+        }
+	printf(" ");
+}
+
+/* Prints out the matchinfo. */
+static void set_print_v0(const void *ip, const struct xt_entry_match *match,
+			 int numeric)
+{
+	const struct xt_set_info_match_v0 *info = (const void *)match->data;
+
+	print_match_v0("match-set", &info->match_set);
+}
+
 /* Prints out the matchinfo. */
 static void set_print(const void *ip, const struct xt_entry_match *match,
                       int numeric)
 {
-	const struct ipt_set_info_match *info = (const void *)match->data;
+	int rev = match->u.user.revision;
+	if (rev == 0) {
+		const struct xt_set_info_match_v0 *info = (const void *)match->data;
+		print_match_v0("match-set", &info->match_set);
+	} else {
+		const struct xt_set_info_match *info = (const void *)match->data;
+		print_match("match-set", &info->match_set);
+	}
+}
 
-	print_match("match-set", &info->match_set);
+static void set_save_v0(const void *ip, const struct xt_entry_match *match)
+{
+	const struct xt_set_info_match_v0 *info = (const void *)match->data;
+
+	print_match_v0("--match-set", &info->match_set);
 }
 
 static void set_save(const void *ip, const struct xt_entry_match *match)
 {
-	const struct ipt_set_info_match *info = (const void *)match->data;
-
-	print_match("--match-set", &info->match_set);
+	int rev = match->u.user.revision;
+	if (rev == 0) {
+		const struct xt_set_info_match_v0 *info = (const void *)match->data;
+		print_match_v0("--match-set", &info->match_set);
+	} else {
+		const struct xt_set_info_match *info = (const void *)match->data;
+		print_match("--match-set", &info->match_set);
+	}
 }
 
-static struct xtables_match set_mt_reg = {
-	.name		= "set",
-	.version	= XTABLES_VERSION,
-	.family		= NFPROTO_IPV4,
-	.size		= XT_ALIGN(sizeof(struct ipt_set_info_match)),
-	.userspacesize	= XT_ALIGN(sizeof(struct ipt_set_info_match)),
-	.help		= set_help,
-	.init		= set_init,
-	.parse		= set_parse,
-	.final_check	= set_check,
-	.print		= set_print,
-	.save		= set_save,
-	.extra_opts	= set_opts,
+static struct xtables_match set_mt_reg[] = {
+	{
+		.name		= "set",
+		.revision       = 0,
+		.version	= XTABLES_VERSION,
+		.family		= NFPROTO_IPV4,
+		.size		= XT_ALIGN(sizeof(struct xt_set_info_match_v0)),
+		.userspacesize	= XT_ALIGN(sizeof(struct xt_set_info_match_v0)),
+		.help		= set_help,
+		.init		= set_init_v0,
+		.parse		= set_parse_v0,
+		.final_check	= set_check,
+		.print		= set_print_v0,
+		.save		= set_save_v0,
+		.extra_opts	= set_opts,
+	},
+	{
+		.name		= "set",
+		.revision       = 1,
+		.version	= XTABLES_VERSION,
+		.family		= NFPROTO_IPV4,
+		.size		= XT_ALIGN(sizeof(struct xt_set_info_match)),
+		.userspacesize	= XT_ALIGN(sizeof(struct xt_set_info_match)),
+		.help		= set_help,
+		.init		= set_init,
+		.parse		= set_parse,
+		.final_check	= set_check,
+		.print		= set_print,
+		.save		= set_save,
+		.extra_opts	= set_opts,
+	},
 };
 
 void _init(void)
 {
-	xtables_register_match(&set_mt_reg);
+	xtables_register_matches(set_mt_reg, ARRAY_SIZE(set_mt_reg));
 }
diff -up iptables-1.4.7/extensions/libipt_SET.c.ipXt_set iptables-1.4.7/extensions/libipt_SET.c
--- iptables-1.4.7/extensions/libipt_SET.c.ipXt_set	2010-03-01 15:11:28.000000000 +0100
+++ iptables-1.4.7/extensions/libipt_SET.c	2015-03-03 22:22:02.625037155 +0100
@@ -37,22 +37,84 @@ static const struct option SET_opts[] =
 	{ .name = NULL }
 };
 
+static void SET_init_v0(struct xt_entry_target *target)
+{
+	struct xt_set_info_target_v0 *info =
+	    (struct xt_set_info_target_v0 *) target->data;
+
+	memset(info, 0, sizeof(struct xt_set_info_target_v0));
+	info->add_set.index =
+	info->del_set.index = IP_SET_INVALID_ID;
+
+}
+
 static void SET_init(struct xt_entry_target *target)
 {
-	struct ipt_set_info_target *info =
-	    (struct ipt_set_info_target *) target->data;
+	struct xt_set_info_target *info =
+	    (struct xt_set_info_target *) target->data;
 
-	memset(info, 0, sizeof(struct ipt_set_info_target));
+	memset(info, 0, sizeof(struct xt_set_info_target));
 	info->add_set.index =
 	info->del_set.index = IP_SET_INVALID_ID;
 
 }
 
 static void
+parse_target_v0(char **argv, int invert, unsigned int *flags,
+		struct xt_set_info_v0 *info, const char *what)
+{
+	if (info->u.flags[0])
+		xtables_error(PARAMETER_PROBLEM,
+			   "--%s can be specified only once", what);
+
+	if (xtables_check_inverse(optarg, &invert, NULL, 0, argv))
+		xtables_error(PARAMETER_PROBLEM,
+			   "Unexpected `!' after --%s", what);
+
+	if (!argv[optind]
+	    || argv[optind][0] == '-' || argv[optind][0] == '!')
+		xtables_error(PARAMETER_PROBLEM,
+			   "--%s requires two args.", what);
+
+	if (strlen(optarg) > IP_SET_MAXNAMELEN - 1)
+		xtables_error(PARAMETER_PROBLEM,
+			   "setname `%s' too long, max %d characters.",
+			   optarg, IP_SET_MAXNAMELEN - 1);
+
+	get_set_byname(optarg, (struct xt_set_info *)info);
+	parse_bindings_v0(argv[optind], info);
+	optind++;
+	
+	*flags = 1;
+}
+
+static int SET_parse_v0(int c, char **argv, int invert, unsigned int *flags,
+                     const void *entry, struct xt_entry_target **target)
+{
+	struct xt_set_info_target_v0 *myinfo =
+	    (struct xt_set_info_target_v0 *) (*target)->data;
+
+	switch (c) {
+	case '1':		/* --add-set <set> <flags> */
+		parse_target_v0(argv, invert, flags,
+				&myinfo->add_set, "add-set");
+		break;
+	case '2':		/* --del-set <set>[:<flags>] <flags> */
+		parse_target_v0(argv, invert, flags,
+				&myinfo->del_set, "del-set");
+		break;
+
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+static void
 parse_target(char **argv, int invert, unsigned int *flags,
-             struct ipt_set_info *info, const char *what)
+	     struct xt_set_info *info, const char *what)
 {
-	if (info->flags[0])
+	if (info->flags)
 		xtables_error(PARAMETER_PROBLEM,
 			   "--%s can be specified only once", what);
 
@@ -80,8 +142,8 @@ parse_target(char **argv, int invert, un
 static int SET_parse(int c, char **argv, int invert, unsigned int *flags,
                      const void *entry, struct xt_entry_target **target)
 {
-	struct ipt_set_info_target *myinfo =
-	    (struct ipt_set_info_target *) (*target)->data;
+	struct xt_set_info_target *myinfo =
+	    (struct xt_set_info_target *) (*target)->data;
 
 	switch (c) {
 	case '1':		/* --add-set <set> <flags> */
@@ -107,7 +169,7 @@ static void SET_check(unsigned int flags
 }
 
 static void
-print_target(const char *prefix, const struct ipt_set_info *info)
+print_target_v0(const char *prefix, const struct xt_set_info_v0 *info)
 {
 	int i;
 	char setname[IP_SET_MAXNAMELEN];
@@ -117,48 +179,101 @@ print_target(const char *prefix, const s
 	get_set_byid(setname, info->index);
 	printf("%s %s", prefix, setname);
 	for (i = 0; i < IP_SET_MAX_BINDINGS; i++) {
-		if (!info->flags[i])
-			break;		
+		if (!info->u.flags[i])
+			break;          
+		printf("%s%s",
+			i == 0 ? " " : ",",
+		       info->u.flags[i] & IPSET_SRC ? "src" : "dst");
+	}
+	printf(" ");
+}
+
+static void
+print_target(const char *prefix, const struct xt_set_info *info)
+{
+	int i;
+	char setname[IP_SET_MAXNAMELEN];
+
+	if (info->index == IP_SET_INVALID_ID)
+		return;
+	get_set_byid(setname, info->index);
+	printf("%s %s", prefix, setname);
+	for (i = 1; i <= info->dim; i++) {
 		printf("%s%s",
-		       i == 0 ? " " : ",",
-		       info->flags[i] & IPSET_SRC ? "src" : "dst");
+		       i == 1 ? " " : ",",
+		       info->flags & (1 << i) ? "src" : "dst");
 	}
 	printf(" ");
 }
 
+static void SET_print_v0(const void *ip, const struct xt_entry_target *target,
+			 int numeric)
+{
+	const struct xt_set_info_target_v0 *info = (const void *)target->data;
+
+	print_target_v0("add-set", &info->add_set);
+	print_target_v0("del-set", &info->del_set);
+}
+
 static void SET_print(const void *ip, const struct xt_entry_target *target,
                       int numeric)
 {
-	const struct ipt_set_info_target *info = (const void *)target->data;
+	const struct xt_set_info_target *info = (const void *)target->data;
 
 	print_target("add-set", &info->add_set);
 	print_target("del-set", &info->del_set);
 }
 
+static void SET_save_v0(const void *ip, const struct xt_entry_target *target)
+{
+	const struct xt_set_info_target_v0 *info = (const void *)target->data;
+
+	print_target_v0("--add-set", &info->add_set);
+	print_target_v0("--del-set", &info->del_set);
+}
+
 static void SET_save(const void *ip, const struct xt_entry_target *target)
 {
-	const struct ipt_set_info_target *info = (const void *)target->data;
+	const struct xt_set_info_target *info = (const void *)target->data;
 
 	print_target("--add-set", &info->add_set);
 	print_target("--del-set", &info->del_set);
 }
 
-static struct xtables_target set_tg_reg = {
-	.name		= "SET",
-	.version	= XTABLES_VERSION,
-	.family		= NFPROTO_IPV4,
-	.size		= XT_ALIGN(sizeof(struct ipt_set_info_target)),
-	.userspacesize	= XT_ALIGN(sizeof(struct ipt_set_info_target)),
-	.help		= SET_help,
-	.init		= SET_init,
-	.parse		= SET_parse,
-	.final_check	= SET_check,
-	.print		= SET_print,
-	.save		= SET_save,
-	.extra_opts	= SET_opts,
+static struct xtables_target set_tg_reg[] = {
+	{
+		.name		= "SET",
+		.revision	= 0,
+		.version	= XTABLES_VERSION,
+		.family		= NFPROTO_IPV4,
+		.size		= XT_ALIGN(sizeof(struct xt_set_info_target_v0)),
+		.userspacesize	= XT_ALIGN(sizeof(struct xt_set_info_target_v0)),
+		.help		= SET_help,
+		.init		= SET_init_v0,
+		.parse		= SET_parse_v0,
+		.final_check	= SET_check,
+		.print		= SET_print_v0,
+		.save		= SET_save_v0,
+		.extra_opts	= SET_opts,
+	},
+	{
+		.name		= "SET",
+		.revision	= 1,
+		.version	= XTABLES_VERSION,
+		.family		= NFPROTO_IPV4,
+		.size		= XT_ALIGN(sizeof(struct xt_set_info_target)),
+		.userspacesize	= XT_ALIGN(sizeof(struct xt_set_info_target)),
+		.help		= SET_help,
+		.init		= SET_init,
+		.parse		= SET_parse,
+		.final_check	= SET_check,
+		.print		= SET_print,
+		.save		= SET_save,
+		.extra_opts	= SET_opts,
+	}
 };
 
 void _init(void)
 {
-	xtables_register_target(&set_tg_reg);
+	xtables_register_targets(set_tg_reg, ARRAY_SIZE(set_tg_reg));
 }
diff -up iptables-1.4.7/extensions/libipt_set.h.ipXt_set iptables-1.4.7/extensions/libipt_set.h
--- iptables-1.4.7/extensions/libipt_set.h.ipXt_set	2015-03-03 22:22:02.610037211 +0100
+++ iptables-1.4.7/extensions/libipt_set.h	2015-03-03 22:22:02.625037155 +0100
@@ -14,21 +14,45 @@
 #endif
 
 static void
-parse_bindings(const char *opt_arg, struct ipt_set_info *info)
+parse_bindings_v0(const char *opt_arg, struct xt_set_info_v0 *info)
 {
 	char *saved = strdup(opt_arg);
 	char *ptr, *tmp = saved;
 	int i = 0;
 	
-	while (i < (IP_SET_MAX_BINDINGS - 1) && tmp != NULL) {
+        while (i < (IP_SET_MAX_BINDINGS - 1) && tmp != NULL) {
 		ptr = strsep(&tmp, ",");
 		if (strncmp(ptr, "src", 3) == 0)
-			info->flags[i++] |= IPSET_SRC;
+			info->u.flags[i++] |= IPSET_SRC;
 		else if (strncmp(ptr, "dst", 3) == 0)
-			info->flags[i++] |= IPSET_DST;
+			info->u.flags[i++] |= IPSET_DST;
 		else
 			xtables_error(PARAMETER_PROBLEM,
-				   "You must spefify (the comma separated list of) 'src' or 'dst'.");
+				      "You must specify (the comma separated list of) 'src' or 'dst'.");
+	}
+
+	if (tmp)
+		xtables_error(PARAMETER_PROBLEM,
+			   "Can't follow bindings deeper than %i.", 
+			   IP_SET_MAX_BINDINGS - 1);
+
+	free(saved);
+}
+
+static void
+parse_bindings(const char *opt_arg, struct xt_set_info *info)
+{
+	char *saved = strdup(opt_arg);
+	char *ptr, *tmp = saved;
+	
+        while (info->dim < IP_SET_MAX_BINDINGS && tmp != NULL) {
+		info->dim++;
+		ptr = strsep(&tmp, ",");
+		if (strncmp(ptr, "src", 3) == 0)
+			info->flags |= (1 << info->dim);
+		else if (strncmp(ptr, "dst", 3) != 0)
+			xtables_error(PARAMETER_PROBLEM,
+				   "You must specify (the comma separated list of) 'src' or 'dst'.");
 	}
 
 	if (tmp)
@@ -66,7 +90,7 @@ static int get_version(unsigned *version
 	return sockfd;
 }
 
-static void get_set_byname(const char *setname, struct ipt_set_info *info)
+static void get_set_byname(const char *setname, struct xt_set_info *info)
 {
 	struct ip_set_req_get_set req;
 	socklen_t size = sizeof(struct ip_set_req_get_set);
diff -up iptables-1.4.7/include/linux/netfilter_ipv4/ipt_set.h.ipXt_set iptables-1.4.7/include/linux/netfilter_ipv4/ipt_set.h
--- iptables-1.4.7/include/linux/netfilter_ipv4/ipt_set.h.ipXt_set	2010-03-01 15:11:28.000000000 +0100
+++ iptables-1.4.7/include/linux/netfilter_ipv4/ipt_set.h	2015-03-03 22:22:02.625037155 +0100
@@ -1,21 +1,59 @@
 #ifndef _IPT_SET_H
 #define _IPT_SET_H
 
+#include <linux/types.h>
 #include <linux/netfilter_ipv4/ip_set.h>
+#include <linux/netfilter/ipset/ip_set.h>
 
-struct ipt_set_info {
+/* Revision 0 interface: backward compatible with netfilter/iptables */
+
+/*
+ * Option flags for kernel operations (xt_set_info_v0)
+ */
+#define IPSET_SRC		0x01	/* Source match/add */
+#define IPSET_DST		0x02	/* Destination match/add */
+#define IPSET_MATCH_INV		0x04	/* Inverse matching */
+
+struct xt_set_info_v0 {
+	ip_set_id_t index;
+	union {
+		__u32 flags[IP_SET_MAX_BINDINGS + 1];
+		struct {
+			__u32 __flags[IP_SET_MAX_BINDINGS];
+			__u8 dim;
+			__u8 flags;
+		} compat;
+	} u;
+};
+
+/* match and target infos */
+struct xt_set_info_match_v0 {
+	struct xt_set_info_v0 match_set;
+};
+
+struct xt_set_info_target_v0 {
+	struct xt_set_info_v0 add_set;
+	struct xt_set_info_v0 del_set;
+};
+
+/* Revision 1: current interface to netfilter/iptables */
+
+#define IPSET_INV_MATCH 1
+
+struct xt_set_info {
 	ip_set_id_t index;
-	u_int32_t flags[IP_SET_MAX_BINDINGS + 1];
+	__u8 dim;
+	__u8 flags;
 };
 
-/* match info */
-struct ipt_set_info_match {
-	struct ipt_set_info match_set;
+/* match and target infos */
+struct xt_set_info_match {
+	struct xt_set_info match_set;
 };
 
-struct ipt_set_info_target {
-	struct ipt_set_info add_set;
-	struct ipt_set_info del_set;
+struct xt_set_info_target {
+	struct xt_set_info add_set;
+	struct xt_set_info del_set;
 };
 
 #endif /*_IPT_SET_H*/
diff -up iptables-1.4.7/include/linux/netfilter_ipv6/ip6t_set.h.ipXt_set iptables-1.4.7/include/linux/netfilter_ipv6/ip6t_set.h
--- iptables-1.4.7/include/linux/netfilter_ipv6/ip6t_set.h.ipXt_set	2015-03-03 22:22:02.625037155 +0100
+++ iptables-1.4.7/include/linux/netfilter_ipv6/ip6t_set.h	2015-03-03 22:22:02.625037155 +0100
@@ -0,0 +1,59 @@
+#ifndef _IP6T_SET_H
+#define _IP6T_SET_H
+
+#include <linux/types.h>
+#include <linux/netfilter_ipv4/ip_set.h>
+#include <linux/netfilter/ipset/ip_set.h>
+
+/* Revision 0 interface: backward compatible with netfilter/iptables */
+
+/*
+ * Option flags for kernel operations (xt_set_info_v0)
+ */
+#define IPSET_SRC		0x01	/* Source match/add */
+#define IPSET_DST		0x02	/* Destination match/add */
+#define IPSET_MATCH_INV		0x04	/* Inverse matching */
+
+struct xt_set_info_v0 {
+	ip_set_id_t index;
+	union {
+		__u32 flags[IP_SET_MAX_BINDINGS + 1];
+		struct {
+			__u32 __flags[IP_SET_MAX_BINDINGS];
+			__u8 dim;
+			__u8 flags;
+		} compat;
+	} u;
+};
+
+/* match and target infos */
+struct xt_set_info_match_v0 {
+	struct xt_set_info_v0 match_set;
+};
+
+struct xt_set_info_target_v0 {
+	struct xt_set_info_v0 add_set;
+	struct xt_set_info_v0 del_set;
+};
+
+/* Revision 1: current interface to netfilter/iptables */
+
+#define IPSET_INV_MATCH 1
+
+struct xt_set_info {
+	ip_set_id_t index;
+	__u8 dim;
+	__u8 flags;
+};
+
+/* match and target infos */
+struct xt_set_info_match {
+	struct xt_set_info match_set;
+};
+
+struct xt_set_info_target {
+	struct xt_set_info add_set;
+	struct xt_set_info del_set;
+};
+
+#endif /*_IP6T_SET_H*/
